import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from sklearn.datasets import load_breast_cancer
from sklearn.model_selection import train_test_split, StratifiedKFold, cross_val_predict
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import (
    accuracy_score,
    cohen_kappa_score,
    f1_score,
    confusion_matrix,
    ConfusionMatrixDisplay,
    RocCurveDisplay,
)

# Helper to compute MAE and RMSE the way Weka reports them:
# MAE/RMSE on probabilistic predictions for the TRUE class.
def mae_rmse_from_proba(y_true, proba, positive_label):
    # proba: probability of the true class for each sample
    # If we passed proba for positive class only, convert to proba of true class.
    true_is_pos = (y_true == positive_label).astype(float)
    # error is |1 - p_true|, where p_true is predicted probability of the true class
    # Given proba is for positive class, p_true = proba if true is positive else (1 - proba)
    p_true = np.where(true_is_pos == 1.0, proba, 1.0 - proba)
    errors = np.abs(1.0 - p_true)
    mae = errors.mean()
    rmse = np.sqrt((errors ** 2).mean())
    return mae, rmse

# Load data
data = load_breast_cancer()
X, y = data.data, data.target  # 0 = malignant, 1 = benign
target_names = ["malignant", "benign"]

# Train-test split (stratified)
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42, stratify=y
)

# Configs to evaluate
k_values = [1, 3, 5, 7, 9]
metrics = ["euclidean", "manhattan"]
weights_options = ["uniform", "distance"]  # scikit-learn supports these two

rows = []
best_model = None
best_acc = -1.0

for metric in metrics:
    for k in k_values:
        for weights in weights_options:
            pipe = Pipeline([
                ("scaler", StandardScaler()),
                ("knn", KNeighborsClassifier(n_neighbors=k, metric=metric, weights=weights))
            ])
            # Fit on train
            pipe.fit(X_train, y_train)
            # Predict on test
            y_pred = pipe.predict(X_test)
            y_proba = pipe.predict_proba(X_test)[:, 0]  # probability of malignant (label 0)

            # Metrics
            acc = accuracy_score(y_test, y_pred) * 100.0
            inc = 100.0 - acc
            kappa = cohen_kappa_score(y_test, y_pred)
            f1_avg = f1_score(y_test, y_pred, average="macro")  # macro average similar to Weka's Avg F-Measure
            mae, rmse = mae_rmse_from_proba(y_test, y_proba, positive_label=0)

            rows.append({
                "K Value": k,
                "Distance Function": metric.capitalize(),
                "Weights": weights,  # added so you can filter uniform vs distance
                "Correct Classified (%)": round(acc, 2),
                "Incorrect Classified (%)": round(inc, 2),
                "Kappa Statistic": round(kappa, 2),
                "MAE": round(mae, 4),
                "RMSE": round(rmse, 4),
                "F-Measure (Avg)": round(f1_avg, 3),
            })

            if acc > best_acc:
                best_acc = acc
                best_model = (pipe, f"k={k}, {metric}, {weights}")

# Build DataFrame
df = pd.DataFrame(rows)

# Sort to resemble your screenshot focus: Euclidean, uniform first
df_sorted = df.sort_values(
    by=["Distance Function", "Weights", "K Value"],
    ascending=[True, True, True]
).reset_index(drop=True)

# Find the row with the highest accuracy (Correct Classified)
best_row = df_sorted.loc[df_sorted["Correct Classified (%)"].idxmax()]

print("\nBest KNN Configuration:")
print(best_row.to_string())

# Print the matrix table
print("\nKNN Matrix Table (generated by code):")
print(df_sorted.to_string(index=False))
#
# # Plot: Accuracy and F-Measure vs K for Euclidean + uniform only
# eu_uniform = df_sorted[(df_sorted["Distance Function"] == "Euclidean") & (df_sorted["Weights"] == "uniform")]
#
# plt.figure()
# plt.plot(eu_uniform["K Value"], eu_uniform["Correct Classified (%)"], marker="o", label="Accuracy (%)")
# plt.plot(eu_uniform["K Value"], eu_uniform["F-Measure (Avg)"], marker="o", label="F-Measure (Avg)")
# plt.title("Euclidean + Uniform: Accuracy and F-Measure vs K")
# plt.xlabel("K")
# plt.ylabel("Score")
# plt.legend()
# plt.tight_layout()
# plt.show()
